
## Denis Gallo (194441) | denis.gallo@studenti.unitn.it

## The Project

### Description of the code

The source code is provided in the package **people**, which is divided into 3 subpackages: people.dao, people.classes, people.generated_classes. 
* In the main package **people** there are the main classes to execute the tasks for this assignment: *myMain.java, PeopleReader.java, PeopleWriter.java, PeopleJson.java.
* In the **classes** subpackage there are the 2 classes needed to understand the xml file people.xml: Person.java and Activity.java.
* In the **dao** subpackage there is only the PeopleStore.java file, needed to store the data during the marshalling and the unmarshalling.
* The **generated_classes** package is used to contain the java classes generated by jaxb xjc from the xml schema people.xsd. These classes are used by the marshaller and the unmarshaller.

In addition in the the project folder we have the previously mentioned **people.xml** which contains our people, exactly 20 manually generated people with some random data, the **people.xsd** file, which contains the xml schema for the xjc library, the **build.xml** file that is needed to execute the ant commands like 
```
ant compile
```
or
```
ant execute.evaluation
```
Last but not least, the **ivy.xml** needed to download or check all the dependencies of the project during the compilation and building.

### Description of the tasks

**XPath and showing data in java from an XML file**
As already mentioned, the people.xml file contains 20 manually generated people, this file is elaborated by the myMain.java class in the people main package.
```
	public void loadXML() throws ParserConfigurationException, SAXException, IOException {
		DocumentBuilderFactory domFactory = DocumentBuilderFactory.newInstance();
		domFactory.setNamespaceAware(true);
		DocumentBuilder builder = domFactory.newDocumentBuilder();
		doc = builder.parse("people.xml");
	}
```

2 other required methods **getActivityDescription** and **getActivityPlace** are implemented in the same class. The XPath queries used are:
```
people/person[@id='"+personId+"']/activitypreference/description/text()
people/person[@id='personId']/activitypreference/place/text()
```

```
	public String getActivityDescription(String personId) throws XPathExpressionException {
		XPath xpath=getXPathObj();
		XPathExpression expr = xpath.compile("people/person[@id='"+personId+"']/activitypreference/description/text()");
		Object result = expr.evaluate(doc, XPathConstants.NODESET);
		NodeList nodes = (NodeList) result;
		return nodes.item(0).getNodeValue();
	}
```

```
	public String getActivityPlace(String personId) throws XPathExpressionException {
		XPath xpath=getXPathObj();
		XPathExpression expr = xpath.compile("people/person[@id='"+personId+"']/activitypreference/place/text()");
		Object result = expr.evaluate(doc, XPathConstants.NODESET);
		NodeList nodes = (NodeList) result;
		return nodes.item(0).getNodeValue();
	}
```

The last 3 methods required are not shown below because they are to long to copy and paste, they however work very similar to the previous 2. The main difference is the XPatch query and the fact that instead of returning a value, they just print on the comand line all the information found by the query. Here are the XPath used in each method:
```
getCompleteList()
XPathExpression expr = xpath.compile("people/person");
```
```
getActivity(String personId)
XPathExpression expr = xpath.compile("people/person[@id='personId']/activitypreference");
```
```
getDateFilteredPeople(String comparator, String mydate)
XPathExpression expr = xpath.compile("//person[(number(substring(translate(activitypreference/startdate,'-T:.',''),1,8)))'comparator'+'myconverteddate'"]");
```
The last XPath is a bit trickier because XPath needs to compare strings. My solution to the problem is to convert both dates (the one in the xml file and my one) into numbers and compare them to decide which is greater than the other (for example 2017-11-17 and 2017-10-31 will be converted as 20171117>20171031).

**Creating the XML schema XSD file for people**
```
<xsd:schema 
    xmlns:xsd="http://www.w3.org/2001/XMLSchema">
    <xsd:complexType name="personType">
        <xsd:sequence>
            <xsd:element name="firstname" type="xsd:string"/>
            <xsd:element name="lastname"  type="xsd:string"/>
            <xsd:element name="birthdate" type="xsd:date"/>
            <xsd:element name="activitypreference" type="activityPreferenceType"	
                minOccurs="0" maxOccurs="1"/>
        </xsd:sequence>
		<xsd:attribute name="id" type="xsd:string"/>
    </xsd:complexType>
    <xsd:complexType name="activityPreferenceType">
        <xsd:sequence>
            <xsd:element name="name" type="xsd:string"/>
            <xsd:element name="description"  type="xsd:string"/>
			<xsd:element name="place" type="xsd:string"/>
            <xsd:element name="startdate"  type="xsd:date"/>
         </xsd:sequence>
		 <xsd:attribute name="id" type="xsd:string"/>
    </xsd:complexType>
</xsd:schema>
```

In the build.xml the jaxb xjc library is configured to generate the java classes from the people.xsd file into the people.generated_classes folder. This classes are now used for the last tasks.

**Marshalling and unmarshalling**
PeopleWriter.java and PeopleReader.java are the 2 classes for the marshalling and unmarshalling. 
PeopleReader does the unmarshalling, creating a PeopleStore instance (the dao in people.dao.PeopleStore.Java, which contains a serializable list of People instances basically) and reading the information from an xml file (in our case people.xml).
```
public class PeopleReader {  	
	public static PeopleStore people = new PeopleStore();

	public static void main(String[] args) throws Exception {
		JAXBContext jc = JAXBContext.newInstance(PeopleStore.class);
        System.out.println();
        System.out.println("Output from our XML File: ");
        Unmarshaller um = jc.createUnmarshaller();
        PeopleStore people = (PeopleStore) um.unmarshal(new FileReader("people.xml"));
        List<PersonType> list = people.getData();
        for (PersonType person : list) {
			//printing the people data to the comand line
        }
    }
```

Similarly, PeopleWriter.java uses a instance of PeopleStore with some generated people to print an xml into generated_people.xml and a copy on the comand line.
```
public class PeopleWriter {  	
	public static PeopleStore people = new PeopleStore();

	public static void initializeDB() throws DatatypeConfigurationException {
		PersonType person1 = new PersonType();
	    //putting some random information into each person
		people.getData().add(person1);
		...
		//adding more people
	}	

	public static void main(String[] args) throws Exception {
		
		initializeDB();
		
		JAXBContext jc = JAXBContext.newInstance(PeopleStore.class);
        Marshaller m = jc.createMarshaller();
        m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);
        
        m.marshal(people,new File("generated_people.xml")); // marshalling into a file
        m.marshal(people, System.out);			  // marshalling into the system default output
    }
}
```

**Converting Java into JSON**
The only difference between the PeopleWriter.java class and the PeopleJson.java one is the main method, the store dao is filled in the same way.
```
public static void main(String[] args) throws Exception {
		
		initializeDB();
		
		// Jackson Object Mapper 
		ObjectMapper mapper = new ObjectMapper();
		
		// Adding the Jackson Module to process JAXB annotations
        JaxbAnnotationModule module = new JaxbAnnotationModule();
        
		// configure as necessary
		mapper.registerModule(module);
		mapper.configure(SerializationFeature.INDENT_OUTPUT, true);
        mapper.configure(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS, true);

        String result = mapper.writeValueAsString(people);
        System.out.println(result);
        mapper.writeValue(new File("generated_people.json"), people);
    }
    
```
    
## Execution
Executing this assignment is pretty standard and simple. There are mainly 3 commands available and that should be used.
```
ant execute.evaluation
```
This one does EVERYTHING, it starts by building and compiling and executes each task required for the evaluation.

```
ant compile
```
Ant compile is useful for just preparing the project to execute some tasks (or even all?). Compile builds up everything and compile.

```
ant execute.taskX
```
This is the only specific command. You can execute a single task by just replacing X with 1 to 6 (for example execute.task3 executes ONLY task 3)

## Additional Notes
Every task is tested and successfully working, however i didn't find a solution to print the dates into the xml file and into the json file in the human-readable form i used on the other tasks. The main problem was to work with an XMLGregorianCalendar in the generated classes (by jaxb) that i couldnt transform into strings or Date objects during the marshalling or the json convertion.
This are 2 examples of what i mean by "no human-readable
